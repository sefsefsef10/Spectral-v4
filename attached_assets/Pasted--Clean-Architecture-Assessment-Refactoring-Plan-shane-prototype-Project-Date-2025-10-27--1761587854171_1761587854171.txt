# Clean Architecture Assessment & Refactoring Plan
## shane-prototype Project

**Date:** 2025-10-27
**Evaluator:** Architecture Assessment
**Target Architecture:** ARCHITECTURE.md (Clean Architecture with Vertical Slicing)

---

## Executive Summary

### Current State

The **shane-prototype** is a sophisticated, production-ready healthcare AI compliance SaaS platform built with TypeScript (Express backend, React frontend) managing complex business domains including certifications, billing, compliance monitoring, and vendor management. The codebase demonstrates **strong technical execution with partial architectural alignment** to Clean Architecture principles.

### Quality Assessment: ‚≠ê‚≠ê‚≠ê (3/5)

**Strengths:**
- ‚úÖ Type-safe throughout with TypeScript and Zod validation
- ‚úÖ Well-documented with clear intent and business context
- ‚úÖ Production infrastructure (Stripe, encryption, audit logging, MFA, SSO)
- ‚úÖ Modern tech stack (React 18, Drizzle ORM, Vite, Inngest workflows)
- ‚úÖ Security-conscious (PHI encryption, CSRF protection, rate limiting)

**Concerns:**
- ‚ö†Ô∏è Anemic domain model (business logic scattered across services)
- ‚ö†Ô∏è Mixed layer responsibilities (routes contain business logic)
- ‚ö†Ô∏è No clear separation between domain, application, and infrastructure
- ‚ö†Ô∏è Tight coupling to specific implementations (storage, services)

**Critical Gaps:**
- ‚ùå No domain entities with business logic
- ‚ùå No use case pattern (application layer missing)
- ‚ùå Dependencies flow outward (violates Dependency Rule)
- ‚ùå Zero test coverage (no unit, integration, or E2E tests found)

### Architectural Alignment: 40% Overall

| Layer | Alignment | Status |
|-------|-----------|--------|
| **Framework** (Routes) | 80% | ‚úÖ Exists but handles too much logic |
| **Application** (Use Cases) | 0% | ‚ùå Completely missing |
| **Domain** (Entities) | 10% | ‚ùå Anemic model, no behavior |
| **Infrastructure** (Repositories) | 60% | ‚ö†Ô∏è Exists but mixed with domain |

### Recommendation

**Proceed with incremental refactoring using vertical slicing approach.** The codebase is well-structured enough to refactor iteratively without a full rewrite. Priority should focus on extracting domain entities and creating use cases for critical business flows first.

**Key Success Factor:** Implement tests BEFORE refactoring to create safety net.

---

## Detailed Technical Analysis

### 1. Current Architecture Pattern

**Identified Pattern:** Service-Oriented Layered Architecture (NOT Clean Architecture)

```
Current Implementation:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ HTTP Request ‚Üí Route Handler                        ‚îÇ
‚îÇ       ‚Üì                                             ‚îÇ
‚îÇ   Service Layer (Domain + Infrastructure mixed)    ‚îÇ
‚îÇ       ‚Üì                                             ‚îÇ
‚îÇ   Storage Layer (Concrete Implementation)          ‚îÇ
‚îÇ       ‚Üì                                             ‚îÇ
‚îÇ   Database (Drizzle ORM + PostgreSQL)              ‚îÇ
‚îÇ       ‚Üì                                             ‚îÇ
‚îÇ   HTTP Response                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Missing Clean Architecture Layers:
‚ùå Domain entities with business logic
‚ùå Use case orchestration (application layer)
‚ùå Repository abstraction (depends on concrete storage)
‚ùå Clear dependency inversion
```

**Example Violation from `server/routes/billing.ts` (lines 57-82):**

```typescript
// ANTI-PATTERN: Route directly calls storage and service
// Bypasses domain and application layers entirely
app.post('/api/billing/subscriptions/health-system', requireAuth, async (req, res) => {
  const user = await storage.getUser(req.session.userId!); // Direct storage access

  if (!user.healthSystemId) {
    return res.status(403).json({ error: '...' }); // Business logic in route
  }

  const result = await stripeBillingService.createHealthSystemSubscription(...);
  res.json(result);
});
```

**Should be (Clean Architecture):**

```typescript
// Framework layer - thin controller
app.post('/api/billing/subscriptions/health-system', requireAuth, async (req, res) => {
  const request = new CreateHealthSystemSubscriptionRequest(
    req.session.userId!,
    req.body.tier
  );

  const result = await createSubscriptionUseCase.execute(request);
  res.status(201).json(result);
});

// Application layer - use case handles orchestration
class CreateHealthSystemSubscriptionUseCase {
  execute(request: CreateHealthSystemSubscriptionRequest): Promise<CreateHealthSystemSubscriptionResponse> {
    const user = await userRepository.findById(request.userId);
    // Validation and business logic...
  }
}
```

### 2. Layer-by-Layer Assessment

#### 2.1 Framework Layer (Routes) - 80% Aligned

**Location:** `server/routes/*.ts` (5 route files)

**Files:**
- `billing.ts` - Subscription management (270 lines)
- `customization.ts` - Branding/settings
- `health-system.ts` - Organization management
- `policy-admin.ts` - Policy configuration
- `provider-connections.ts` - EHR integrations

**Strengths:**
- ‚úÖ Clear HTTP endpoint definitions with RESTful conventions
- ‚úÖ Request validation using Zod schemas
- ‚úÖ Authentication middleware (`requireAuth`)
- ‚úÖ Comprehensive error handling and logging
- ‚úÖ Webhook signature verification (Stripe)
- ‚úÖ Well-documented with JSDoc comments

**Gaps and Violations:**

1. **Business Logic in Routes** (lines 64-66 in billing.ts):
```typescript
if (!user.healthSystemId) {
  return res.status(403).json({ error: 'Only health system users can create...' });
}
```
*Should be:* Validation in domain entity or use case

2. **Direct Storage Access** (line 59):
```typescript
const user = await storage.getUser(req.session.userId!);
```
*Should be:* Use case should orchestrate, route should only call use case

3. **No Request/Response DTOs:**
```typescript
// Current: Raw body and JSON responses
const { tier } = createHealthSystemSubscriptionSchema.parse(req.body);
res.json(result);
```
*Should be:* Explicit request/response models from application layer

4. **Mixed Concerns:**
Routes handle: validation, authorization, business logic, data access, response formatting

**Refactoring Priority:** Medium (clean up after application layer is created)

---

#### 2.2 Application Layer (Use Cases) - 0% Aligned ‚ùå CRITICAL

**Location:** DOES NOT EXIST

**Expected Structure (from ARCHITECTURE.md):**
```
server/application/
‚îú‚îÄ‚îÄ billing/
‚îÇ   ‚îú‚îÄ‚îÄ CreateHealthSystemSubscription.ts  # Use case + Request/Response
‚îÇ   ‚îú‚îÄ‚îÄ CreateVendorSubscription.ts
‚îÇ   ‚îú‚îÄ‚îÄ CheckUsageLimits.ts
‚îÇ   ‚îî‚îÄ‚îÄ Views.ts                            # Shared view models
‚îú‚îÄ‚îÄ certifications/
‚îÇ   ‚îú‚îÄ‚îÄ ProcessApplication.ts
‚îÇ   ‚îú‚îÄ‚îÄ ApproveApplication.ts
‚îÇ   ‚îî‚îÄ‚îÄ RunVendorTests.ts
‚îú‚îÄ‚îÄ policies/
‚îÇ   ‚îú‚îÄ‚îÄ EvaluateAISystem.ts
‚îÇ   ‚îú‚îÄ‚îÄ CreatePolicy.ts
‚îÇ   ‚îî‚îÄ‚îÄ ResolveViolation.ts
‚îî‚îÄ‚îÄ ai-systems/
    ‚îú‚îÄ‚îÄ RegisterAISystem.ts
    ‚îú‚îÄ‚îÄ UpdateAISystem.ts
    ‚îî‚îÄ‚îÄ DeployAISystem.ts
```

**Critical Impact:**

Without an application layer:
- ‚ùå No clear orchestration of business workflows
- ‚ùå Business logic scattered between routes and services
- ‚ùå Cannot test workflows in isolation
- ‚ùå Cross-cutting concerns (auth, transactions) duplicated
- ‚ùå No clear use case boundaries for feature development

**Example: Current Certification Flow**

**Current Implementation** (certification-processor.ts - all in one service):
```typescript
// 286 lines mixing orchestration, domain logic, and infrastructure
export async function processCertificationApplication(applicationId: string) {
  const application = await storage.getCertificationApplication(applicationId);

  // Domain logic mixed with orchestration
  const checks = {
    documentationComplete: checkDocumentationComplete(application),
    complianceStatementsValid: checkComplianceStatements(application),
    // ... more checks
  };

  // Infrastructure calls mixed in
  const allTestResults = await vendorTestingSuite.runAllTests(testConfig);

  // Scoring algorithm in service (should be in domain)
  let score = 0;
  if (checks.documentationComplete) score += 20;
  // ...

  // Direct storage call
  await storage.updateCertificationApplicationStatus(...);
}
```

**Should be (Clean Architecture):**

```typescript
// APPLICATION LAYER - Use case orchestrates workflow
class ProcessCertificationApplicationUseCase {
  constructor(
    private certificationRepo: CertificationApplicationRepository,
    private testingGateway: VendorTestingGateway
  ) {}

  async execute(request: ProcessCertificationRequest): Promise<ProcessCertificationResponse> {
    // Load aggregate
    const application = await this.certificationRepo.findById(request.applicationId);

    // Domain logic - entity has business rules
    const result = application.evaluate();

    // Infrastructure - gateway handles external testing
    const testResults = await this.testingGateway.runTests(application);
    application.applyTestResults(testResults);

    // Persist
    await this.certificationRepo.save(application);

    return ProcessCertificationResponse.fromEntity(application);
  }
}

// DOMAIN LAYER - Entity contains business logic
class CertificationApplication {
  private checks: CertificationChecks;

  evaluate(): EvaluationResult {
    this.checks.validateDocumentation();
    this.checks.validateCompliance();
    return new EvaluationResult(this.calculateScore(), this.checks);
  }

  calculateScore(): number {
    // Business rules encapsulated in entity
    let score = 0;
    if (this.checks.documentationComplete) score += 20;
    if (this.checks.complianceStatementsValid) score += 20;
    // ...
    return score;
  }

  applyTestResults(results: TestResults): void {
    // Domain logic for interpreting test results
    this.checks.updateFromTests(results);
  }
}
```

**Refactoring Priority:** üî• **HIGHEST** - Application layer is the linchpin of Clean Architecture

---

#### 2.3 Domain Layer (Entities) - 10% Aligned ‚ùå CRITICAL

**Location:** `shared/schema.ts` (database schema only - NOT domain layer)

**Current State: Anemic Domain Model Anti-Pattern**

The project uses Drizzle ORM schema definitions as domain models, which are just data structures with no behavior:

```typescript
// shared/schema.ts - Database schema, not domain entities
export const aiSystems = pgTable("ai_systems", {
  id: varchar("id").primaryKey(),
  name: text("name").notNull(),
  department: text("department").notNull(),
  riskLevel: text("risk_level").notNull(),
  status: text("status").notNull(),
  healthSystemId: varchar("health_system_id"),
  vendorId: varchar("vendor_id"),
  // ... more fields
  // NO METHODS, NO VALIDATION, NO BUSINESS RULES
});

export type AISystem = typeof aiSystems.$inferSelect;
export type InsertAISystem = typeof aiSystems.$inferInsert;
```

**Problems with this approach:**

1. **No encapsulation** - All fields public, no validation
2. **No behavior** - Business logic lives in services, not entities
3. **Anemic** - Entities are just data bags, violating OOP principles
4. **Tight coupling** - Database schema IS the domain model
5. **Cannot evolve independently** - Domain changes require migration

**Example: Business Logic in Services (should be in Domain)**

**File:** `server/services/certification-processor.ts` (lines 143-157)

```typescript
// ANTI-PATTERN: Scoring algorithm in service file
let score = 0;
if (checks.documentationComplete) score += 20;
if (checks.complianceStatementsValid) score += 20;
if (checks.deploymentHistoryValid) score += 10;
if (checks.phiExposureTest) score += 15;
if (checks.clinicalAccuracyTest) score += 15;
if (checks.biasDetectionTest) score += 10;
if (checks.securityScanTest) score += 10;

const passed = Object.values(checks).every(check => check === true);
```

**Should be:**

```typescript
// DOMAIN LAYER - domain/entities/CertificationApplication.ts
class CertificationApplication {
  private _checks: CertificationChecks;
  private _tierRequested: CertificationTier;

  calculateScore(): CertificationScore {
    const weights = {
      documentation: 20,
      compliance: 20,
      deployment: 10,
      phiTest: 15,
      clinicalTest: 15,
      biasTest: 10,
      securityTest: 10
    };

    return new CertificationScore(
      this._checks.calculateWeightedScore(weights)
    );
  }

  hasPassedEvaluation(): boolean {
    return this._checks.allChecksPassed() &&
           this.calculateScore().meetsThreshold(this._tierRequested);
  }

  // More business logic methods...
}
```

**Additional Missing Domain Concepts:**

Based on the codebase analysis, these should be domain entities but don't exist:

| Missing Entity | Business Logic Location | Lines of Code |
|----------------|------------------------|---------------|
| `CertificationApplication` | certification-processor.ts | 287 |
| `Policy` | policy-enforcement-engine.ts | 620 |
| `AISystem` | Multiple services | 500+ |
| `Subscription` | stripe-billing.ts | 400+ |
| `ComplianceReport` | Multiple services | 300+ |
| `Deployment` | Multiple services | 200+ |

**Impact:**

- ‚ùå Business logic scattered across 56+ service files
- ‚ùå Difficult to test domain rules in isolation
- ‚ùå Duplicate validation logic across services
- ‚ùå Cannot reason about business rules without reading code
- ‚ùå Hard to onboard new developers (no clear domain model)

**Refactoring Priority:** üî• **HIGHEST** - Domain layer is the heart of Clean Architecture

---

#### 2.4 Infrastructure Layer - 60% Aligned ‚ö†Ô∏è

**Location:** `server/services/`, `server/storage.ts`, `server/db.ts`

**Components:**

| Component | Purpose | Status |
|-----------|---------|--------|
| `storage.ts` | Data access layer | ‚ö†Ô∏è Exists but not abstracted |
| `db.ts` | Drizzle ORM setup | ‚úÖ Good separation |
| `encryption.ts` | Field encryption | ‚úÖ Good separation |
| `phi-encryption.ts` | PHI-specific encryption | ‚úÖ HIPAA compliant |
| `stripe-billing.ts` | Payment gateway | ‚ö†Ô∏è Mixed domain/infra |
| `epic-fhir-service.ts` | EHR integration | ‚ö†Ô∏è Mixed domain/infra |
| `arize-client.ts` | ML monitoring | ‚úÖ Good gateway |
| `langsmith-client.ts` | LLM tracing | ‚úÖ Good gateway |
| `email-notification.ts` | SendGrid integration | ‚úÖ Good gateway |

**Strengths:**

‚úÖ **Clear external integrations:**
- Stripe for billing
- Epic FHIR for health system data
- Arize/LangSmith for AI monitoring
- SendGrid/Twilio/Slack for notifications
- AWS S3 for file storage

‚úÖ **Security implementations:**
- AES-256-GCM encryption for PHI
- Separate encryption for different data types
- Secure credential storage

‚úÖ **Database abstraction with Drizzle ORM:**
- Type-safe query builder
- Migration management
- Connection pooling with Neon serverless

**Critical Gap: No Repository Pattern**

**Current:** `storage.ts` defines interface and implementation together

```typescript
// storage.ts - Interface and implementation in same file
export interface IStorage {
  getUser(id: string): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  // ... 200+ methods
}

class Storage implements IStorage {
  // Direct Drizzle ORM usage
  async getUser(id: string): Promise<User | undefined> {
    const result = await db.select().from(users).where(eq(users.id, id));
    return result[0];
  }
  // ... implementations
}

// Singleton export - hard to test, hard to swap
export const storage = new Storage();
```

**Problems:**

1. **Tight coupling** - All code depends on concrete `Storage` class
2. **Hard to test** - Cannot easily mock, singleton pattern
3. **Violates Dependency Inversion** - Inner layers depend on outer layers
4. **Cannot swap implementations** - Tied to Drizzle/PostgreSQL

**Should be (Repository Pattern):**

```typescript
// DOMAIN LAYER - domain/repositories/UserRepository.ts
export interface UserRepository {
  findById(id: string): Promise<User | null>;
  findByUsername(username: string): Promise<User | null>;
  save(user: User): Promise<void>;
}

// INFRASTRUCTURE LAYER - infrastructure/repositories/DrizzleUserRepository.ts
export class DrizzleUserRepository implements UserRepository {
  constructor(private db: DrizzleDB) {}

  async findById(id: string): Promise<User | null> {
    const result = await this.db.select().from(usersTable).where(eq(usersTable.id, id));
    return result[0] ? this.toDomainEntity(result[0]) : null;
  }

  private toDomainEntity(row: UserRow): User {
    // Map database row to domain entity
    return new User(row.id, row.username, row.email, ...);
  }
}

// FRAMEWORK LAYER - Dependency injection
const userRepository: UserRepository = new DrizzleUserRepository(db);
const useCase = new CreateUserUseCase(userRepository);
```

**Additional Infrastructure Issues:**

1. **God Services** - Single service files with 500-600+ lines:
   - `policy-enforcement-engine.ts` (620 lines) - Should be split
   - `stripe-billing.ts` (400+ lines) - Mixed domain and infrastructure

2. **Business logic in infrastructure:**
```typescript
// stripe-billing.ts line 85-95
// Business rule in infrastructure layer
canAddAISystem(healthSystemId: string) {
  const healthSystem = await storage.getHealthSystem(healthSystemId);

  const tierLimits = {
    'starter': 3,
    'professional': 10,
    'enterprise': 999999
  };

  const limit = tierLimits[healthSystem.subscriptionTier] || 0;
  // ... should be in Subscription domain entity
}
```

**Refactoring Priority:** Medium-High (after domain and application layers)

---

### 3. Anti-Patterns Identified

#### 3.1 Anemic Domain Model ‚ö†Ô∏è **CRITICAL**

**Definition:** Domain entities with only data (getters/setters) and no business logic behavior.

**Evidence:**

All domain logic lives in service files instead of entities:

```typescript
// Current: Anemic model (just data structure)
type AISystem = {
  id: string;
  name: string;
  riskLevel: string;  // Just a string, no validation
  status: string;      // No state machine
  // ... no methods
};

// Business logic scattered in services
function canDeployAISystem(system: AISystem): boolean {
  if (system.status === 'inactive') return false;
  if (system.riskLevel === 'critical' && !system.vendorId) return false;
  // ... logic in function, not in entity
}
```

**Should be:**

```typescript
// Rich domain model with behavior
class AISystem {
  private _status: SystemStatus;
  private _riskLevel: RiskLevel;
  private _vendor: Vendor | null;

  canDeploy(): boolean {
    return this._status.isActive() &&
           this._riskLevel.allowsDeployment(this._vendor);
  }

  deploy(): void {
    if (!this.canDeploy()) {
      throw new DomainError('Cannot deploy system in current state');
    }
    this._status = SystemStatus.DEPLOYED;
    this.raiseEvent(new SystemDeployedEvent(this.id));
  }
}
```

**Impact:**
- Difficult to reason about business rules
- Duplicate validation logic across multiple services
- Cannot test business logic without infrastructure
- Easy to introduce bugs by bypassing validation

**Prevalence:** üî• **Pervasive** - Affects entire codebase (56+ service files)

---

#### 3.2 God Services ‚ö†Ô∏è **HIGH**

**Definition:** Single service classes handling too many responsibilities, violating Single Responsibility Principle.

**Evidence:**

**File:** `server/services/policy-enforcement-engine.ts` (620 lines)

Responsibilities mixed in one class:
1. Policy creation (lines 96-125)
2. Policy evaluation (lines 129-293)
3. Violation logging (lines 405-436)
4. Alert generation (lines 373-400)
5. Statistics calculation (lines 595-617)
6. Policy CRUD operations (lines 441-561)

**Should be split into:**

```typescript
// Domain layer
class Policy { /* entity with evaluation logic */ }
class PolicyEvaluator { /* domain service */ }

// Application layer
class CreatePolicyUseCase { /* */ }
class EvaluateAISystemUseCase { /* */ }
class ResolvePolicyViolationUseCase { /* */ }

// Infrastructure layer
class PolicyRepository { /* persistence */ }
class PolicyViolationRepository { /* persistence */ }
class AlertGateway { /* notification sending */ }
```

**Other examples:**
- `stripe-billing.ts` (400+ lines) - Billing + subscription + usage limits + webhooks
- `certification-processor.ts` (287 lines) - Validation + testing + scoring + persistence

**Impact:**
- Hard to test (many dependencies)
- Hard to maintain (too much to understand)
- Violates SRP (multiple reasons to change)
- Difficult to reuse components

---

#### 3.3 Leaking Infrastructure into Framework ‚ö†Ô∏è **HIGH**

**Definition:** Framework layer (routes) directly accessing infrastructure (storage, databases).

**Evidence:**

**File:** `server/routes/billing.ts` (line 59)

```typescript
app.post('/api/billing/subscriptions/health-system', requireAuth, async (req, res) => {
  // Route directly accesses storage (infrastructure layer)
  const user = await storage.getUser(req.session.userId!);
  const healthSystem = await storage.getHealthSystem(user.healthSystemId);

  // Route directly calls service (infrastructure layer)
  const result = await stripeBillingService.createHealthSystemSubscription(...);
});
```

**Violates Dependency Rule:**
```
Framework (outer) ‚Üí Infrastructure (outer) ‚ùå WRONG
Should be:
Framework ‚Üí Application ‚Üí Domain ‚Üê Infrastructure ‚úÖ
```

**Should be:**

```typescript
app.post('/api/billing/subscriptions/health-system', requireAuth, async (req, res) => {
  const request = new CreateHealthSystemSubscriptionRequest(
    req.session.userId!,
    req.body.tier
  );

  // Route only calls use case (application layer)
  const response = await createSubscriptionUseCase.execute(request);

  res.status(201).json(response);
});
```

**Impact:**
- Tight coupling between layers
- Cannot test routes without database
- Hard to swap infrastructure implementations
- Violates Clean Architecture principles

---

#### 3.4 No Repository Pattern ‚ö†Ô∏è **MEDIUM-HIGH**

**Definition:** No abstraction between business logic and data access, tight coupling to ORM.

**Evidence:**

Direct usage of `storage` singleton throughout codebase:

```typescript
// Services directly depend on concrete storage implementation
import { storage } from "../storage";

async function someBusinessLogic() {
  const user = await storage.getUser(id);  // Depends on concrete class
  // ... if we want to swap ORMs, we have to change all services
}
```

**Problems:**

1. **Cannot mock for testing** - Singleton pattern makes testing difficult
2. **Tight coupling to Drizzle ORM** - Cannot easily migrate to different database
3. **Violates Dependency Inversion** - Business logic depends on infrastructure details
4. **No clear aggregate boundaries** - 200+ methods on single interface

**Should be:**

```typescript
// Domain layer defines interface
interface UserRepository {
  findById(id: string): Promise<User | null>;
  save(user: User): Promise<void>;
}

// Business logic depends on interface (injected)
class SomeUseCase {
  constructor(private userRepo: UserRepository) {}

  async execute() {
    const user = await this.userRepo.findById(id);  // Depends on abstraction
    // ... easy to mock, easy to swap implementations
  }
}

// Infrastructure provides implementation
class DrizzleUserRepository implements UserRepository { /* ... */ }
```

---

#### 3.5 DTOs Everywhere ‚ö†Ô∏è **MEDIUM**

**Definition:** Database schema types used across all layers, causing tight coupling.

**Evidence:**

```typescript
// shared/schema.ts exports used everywhere
import type { User, AISystem, Vendor } from "@shared/schema";

// Used in routes (framework layer)
app.get('/api/users', async (req, res) => {
  const users: User[] = await storage.getUsers();  // DB type leaks to API
  res.json(users);
});

// Used in services (domain/application layer)
function validateUser(user: User) { /* ... */ }

// Used in frontend (presentation layer)
interface DashboardProps {
  systems: AISystem[];  // DB schema in React components
}
```

**Problems:**

1. **Tight coupling** - Changing database schema breaks API contracts
2. **Security risk** - Accidentally expose internal fields (passwords, secrets)
3. **Cannot evolve independently** - Domain and persistence locked together
4. **Frontend depends on backend** - Shared types create tight coupling

**Should be:**

```typescript
// Domain layer - pure business entities
class User {
  constructor(
    readonly id: string,
    readonly username: string,
    readonly email: Email  // Value object
  ) {}
}

// Application layer - API DTOs
interface UserView {
  id: string;
  username: string;
  email: string;
  // Only fields needed for API response
}

// Infrastructure layer - database models
interface UserRow {
  id: string;
  username: string;
  email: string;
  password_hash: string;  // Never exposed to API
  created_at: Date;
}

// Explicit mapping between layers
class UserView {
  static fromEntity(user: User): UserView {
    return { id: user.id, username: user.username, email: user.email.value };
  }
}
```

---

#### 3.6 Missing Tests ‚ö†Ô∏è **CRITICAL**

**Definition:** No automated tests to validate behavior or enable safe refactoring.

**Evidence:**

```bash
$ find . -name "*.test.ts" -o -name "*.spec.ts"
# Returns: 0 files found
```

**Impact:**

1. **Cannot refactor safely** - No regression detection
2. **No documentation** - Tests serve as executable specifications
3. **Unknown behavior** - Cannot verify business rules work correctly
4. **High risk** - Any change could break production
5. **Cannot evolve** - Fear of breaking things prevents improvements

**Note:** Found test files in `server/services/vendor-testing/` but these are testing tools FOR vendors, not unit tests for the codebase.

**Test Strategy Needed:**

```
Testing Pyramid:

        /\
       /E2E\      ‚Üê Fewest (critical user flows)
      /------\
     /  Integ \   ‚Üê Medium (use cases + repositories)
    /----------\
   /    Unit    \ ‚Üê Most (domain entities, value objects)
  /              \
```

**Priority:** üî• **CRITICAL** - Must implement tests before major refactoring

---

### 4. Frontend Assessment

**Structure:** `client/src/` - Feature-based organization

**Files:**
- ~50 React components organized by feature
- Custom hooks for API calls (`use-toast`, `use-websocket`)
- Utility libraries (`queryClient`, `csv-export`, `utils`)
- Pages for routing (`Dashboard`, etc.)

**Assessment:** ‚úÖ **Appropriate for complexity level**

The frontend does **NOT need full Clean Architecture** implementation. Per ARCHITECTURE.md:

> "Frontend architecture should match frontend complexity. Over-engineering is more common than under-engineering in UI development."

**Current Pattern:**

```
client/src/
‚îú‚îÄ‚îÄ components/          # Feature-organized UI
‚îÇ   ‚îú‚îÄ‚îÄ billing/
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/
‚îÇ   ‚îú‚îÄ‚îÄ customization/
‚îÇ   ‚îî‚îÄ‚îÄ ui/              # Radix UI component library
‚îú‚îÄ‚îÄ pages/               # Route pages
‚îú‚îÄ‚îÄ hooks/               # API calls + custom logic
‚îî‚îÄ‚îÄ lib/                 # Utilities (queryClient, csv-export)
```

**Alignment with ARCHITECTURE.md Guidance:**

The current structure follows the recommended "start simple" approach:
- ‚úÖ Feature-based organization (clear domain grouping)
- ‚úÖ Shared UI components library
- ‚úÖ Custom hooks for reusable logic
- ‚úÖ React Query for server state management
- ‚úÖ Minimal abstraction overhead

**When to introduce Clean Architecture to frontend:**

Only if these conditions emerge:
- Complex business logic needs testing independent of React
- Multiple UIs sharing same logic (web + mobile)
- Rich offline capabilities requiring local domain model
- Frequent framework changes

**Recommendation:**

**Keep current frontend structure.** Only extract complex domain logic if it emerges naturally (e.g., complex multi-step form validation with business rules).

If extraction becomes necessary later, start with:
1. Extract pure validation functions to `lib/validation/`
2. Create domain models for complex client-side state
3. Avoid creating repositories for simple HTTP calls

**Frontend Priority:** ‚úÖ **NO ACTION NEEDED** - Focus refactoring effort on backend

---

### 5. Positive Observations

Despite architectural gaps, the codebase demonstrates **strong engineering practices:**

#### 5.1 Type Safety ‚úÖ

**Evidence:**
- Comprehensive TypeScript usage (strict mode)
- Runtime validation with Zod schemas
- Type inference with Drizzle ORM
- No usage of `any` type (good discipline)

```typescript
// Example: Type-safe validation
const createHealthSystemSubscriptionSchema = z.object({
  tier: z.enum(['starter', 'professional', 'enterprise']),
});

type CreateHealthSystemSubscriptionRequest = z.infer<typeof createHealthSystemSubscriptionSchema>;
```

#### 5.2 Security & Compliance ‚úÖ

**HIPAA-compliant implementations:**

1. **PHI Encryption** (`phi-encryption.ts`):
   - AES-256-GCM encryption for sensitive data
   - Separate encryption keys for different data types
   - Encrypted at rest (database) and in transit

2. **Audit Logging** (`auditLogs` table):
   - Comprehensive tracking of all actions
   - IP address and user agent logging
   - Before/after state for compliance investigations
   - Indexed for fast queries

3. **Authentication & Authorization:**
   - MFA/2FA support with TOTP
   - Enterprise SSO via WorkOS
   - Role-based permissions
   - Session management with secure cookies

4. **API Security:**
   - CSRF protection
   - Rate limiting
   - API key management for partners
   - Webhook signature verification

#### 5.3 Production Infrastructure ‚úÖ

**Robust integrations:**

| Service | Purpose | Implementation Quality |
|---------|---------|----------------------|
| Stripe | Billing/subscriptions | ‚úÖ Webhook handling, idempotency |
| Epic FHIR | EHR integration | ‚úÖ OAuth 2.0, resource sync |
| WorkOS | Enterprise SSO | ‚úÖ SAML, directory sync |
| Inngest | Background jobs | ‚úÖ Retry logic, observability |
| AWS S3 | File storage | ‚úÖ Presigned URLs, encryption |
| SendGrid/Twilio | Notifications | ‚úÖ Templates, retry logic |
| Arize/LangSmith | AI monitoring | ‚úÖ Metric tracking |

#### 5.4 Documentation ‚úÖ

**Well-documented code:**

```typescript
/**
 * üîí POLICY ENFORCEMENT ENGINE - Phase 4 Business Model
 *
 * Real-time governance policy evaluation and enforcement
 * Enables automated compliance policy management
 */
```

- Clear intent in comments
- Business context explained
- Phase/priority indicators
- Complex logic documented

#### 5.5 Modern Technology Stack ‚úÖ

**Backend:**
- Node.js 20+ with TypeScript 5
- Express.js (mature, well-understood)
- Drizzle ORM (type-safe, modern)
- PostgreSQL with Neon (serverless, scalable)
- Pino structured logging

**Frontend:**
- React 18 (latest)
- Vite (fast builds)
- TailwindCSS (utility-first)
- Radix UI (accessible components)
- React Query (excellent server state)

**DevOps:**
- TypeScript build pipeline
- Database migrations (Drizzle)
- Environment-based configuration

#### 5.6 Domain Understanding ‚úÖ

**Clear business concepts:**

The codebase demonstrates deep understanding of the healthcare AI compliance domain:

- **Certification tiers** (Silver/Gold/Platinum) with specific requirements
- **Policy enforcement** with approval workflows
- **Risk levels** with deployment restrictions
- **Compliance frameworks** (HIPAA, NIST AI RMF, FDA, ISO)
- **Vendor testing** (PHI exposure, bias detection, clinical accuracy)
- **Usage-based billing** with tier limits

This domain knowledge is a huge asset - refactoring will preserve and better structure this valuable business logic.

---

## High-Level Refactoring Plan

### Strategy: Incremental Vertical Slicing with Layer Sanctity

**Principle:** Refactor ONE business capability at a time, implementing all layers for that capability before moving to the next.

**Why this approach:**
- ‚úÖ Incremental value delivery (existing features keep working)
- ‚úÖ Risk mitigation (validate each refactor before proceeding)
- ‚úÖ Team learning (build muscle memory for Clean Architecture)
- ‚úÖ Maintain working system throughout (no "big bang" rewrite)
- ‚úÖ Early feedback (can adjust approach based on learnings)

**Key Disciplines:**

1. **Vertical Slicing** (WHEN to build): One user story at a time, P1 ‚Üí P2 ‚Üí P3
2. **Layer Sanctity** (HOW to build): Always maintain inward-pointing dependencies
3. **Test-First** (SAFETY): Write characterization tests before refactoring
4. **Parallel Implementation** (RISK): New code alongside old, gradual cutover
5. **Feature Flags** (CONTROL): Toggle between old/new implementations

---

### Phase 1: Foundation Setup (Weeks 1-2)

**Goal:** Establish architectural skeleton and testing infrastructure WITHOUT breaking existing code.

#### Tasks:

**1.1 Create Directory Structure**

```bash
server/
‚îú‚îÄ‚îÄ domain/                     # NEW - Pure business logic
‚îÇ   ‚îú‚îÄ‚îÄ entities/              # Business entities with behavior
‚îÇ   ‚îú‚îÄ‚îÄ value-objects/         # Immutable domain values
‚îÇ   ‚îú‚îÄ‚îÄ repositories/          # Repository interfaces (abstractions)
‚îÇ   ‚îú‚îÄ‚îÄ services/              # Domain services (pure logic)
‚îÇ   ‚îî‚îÄ‚îÄ events/                # Domain events
‚îÇ
‚îú‚îÄ‚îÄ application/               # NEW - Use cases and orchestration
‚îÇ   ‚îú‚îÄ‚îÄ billing/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateHealthSystemSubscription.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CheckUsageLimits.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Views.ts
‚îÇ   ‚îú‚îÄ‚îÄ certifications/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProcessApplication.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ApproveApplication.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Views.ts
‚îÇ   ‚îú‚îÄ‚îÄ policies/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EvaluateAISystem.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreatePolicy.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Views.ts
‚îÇ   ‚îî‚îÄ‚îÄ ai-systems/
‚îÇ       ‚îú‚îÄ‚îÄ RegisterAISystem.ts
‚îÇ       ‚îî‚îÄ‚îÄ Views.ts
‚îÇ
‚îú‚îÄ‚îÄ infrastructure/            # REORGANIZE EXISTING
‚îÇ   ‚îú‚îÄ‚îÄ repositories/          # Repository implementations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DrizzleUserRepository.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DrizzleAISystemRepository.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ gateways/             # External service integrations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StripeGateway.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EpicFHIRGateway.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EmailGateway.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ encryption/           # Move encryption services here
‚îÇ   ‚îî‚îÄ‚îÄ persistence/          # Database setup
‚îÇ       ‚îú‚îÄ‚îÄ db.ts
‚îÇ       ‚îî‚îÄ‚îÄ migrations/
‚îÇ
‚îî‚îÄ‚îÄ frameworks/                # RENAME FROM routes/
    ‚îî‚îÄ‚îÄ http/
        ‚îú‚îÄ‚îÄ routes/           # Express routes (thin)
        ‚îú‚îÄ‚îÄ middleware/       # Existing middleware
        ‚îî‚îÄ‚îÄ controllers/      # NEW - Thin controllers
```

**1.2 Install Testing Framework**

```bash
npm install --save-dev vitest @vitest/ui
npm install --save-dev @types/node
npm install --save-dev @faker-js/faker  # Test data generation
```

**vitest.config.ts:**
```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: ['**/node_modules/**', '**/dist/**']
    }
  }
});
```

**package.json scripts:**
```json
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage"
  }
}
```

**1.3 Set Up Architectural Fitness Functions**

**ESLint plugin to enforce layer boundaries:**

```bash
npm install --save-dev eslint-plugin-import
```

**.eslintrc.js:**
```javascript
module.exports = {
  rules: {
    'import/no-restricted-paths': ['error', {
      zones: [
        // Domain cannot import from outer layers
        {
          target: './server/domain',
          from: ['./server/application', './server/infrastructure', './server/frameworks']
        },
        // Application can only import from domain
        {
          target: './server/application',
          from: ['./server/infrastructure', './server/frameworks']
        },
        // Infrastructure can import domain + application
        {
          target: './server/infrastructure',
          from: ['./server/frameworks']
        }
      ]
    }]
  }
};
```

**Script to detect circular dependencies:**

```typescript
// scripts/check-architecture.ts
import madge from 'madge';

madge('server/', { fileExtensions: ['ts'] })
  .then((res) => {
    const circular = res.circular();
    if (circular.length > 0) {
      console.error('Circular dependencies found:', circular);
      process.exit(1);
    }
    console.log('‚úÖ No circular dependencies');
  });
```

**Deliverables:**
- [ ] Directory structure created
- [ ] Vitest installed and configured
- [ ] Sample test passing
- [ ] ESLint rules enforcing layers
- [ ] Architecture check script

**Risk:** Low - No changes to existing code
**Duration:** 3-5 days

---

### Phase 2: Pilot Refactor - Certification Flow (Weeks 3-4)

**Goal:** Refactor ONE complete business capability end-to-end to validate the approach and train the team.

**Why Certification Flow:**
- ‚úÖ Well-defined business rules (scoring, validation)
- ‚úÖ Medium complexity (not too simple, not too complex)
- ‚úÖ Clear domain concepts (Application, Certification, Test Results)
- ‚úÖ High business value (core platform feature)
- ‚úÖ Self-contained (fewer dependencies on other features)

#### Step 2.1: Write Characterization Tests

**Purpose:** Create safety net BEFORE refactoring

```typescript
// tests/integration/certification-processor.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { processCertificationApplication } from '../../server/services/certification-processor';

describe('Certification Processor (Characterization Tests)', () => {
  beforeEach(async () => {
    // Set up test database with known state
  });

  it('should pass Silver tier with 1 document and HIPAA compliance', async () => {
    // Arrange
    const applicationId = await createTestApplication({
      tierRequested: 'Silver',
      documentationUrls: ['https://example.com/hipaa.pdf'],
      complianceStatements: { hipaa: true }
    });

    // Act
    const result = await processCertificationApplication(applicationId);

    // Assert
    expect(result.passed).toBe(true);
    expect(result.score).toBeGreaterThanOrEqual(40); // Document + compliance
  });

  it('should fail Gold tier without NIST compliance', async () => {
    // Test existing behavior to lock it in
  });

  // More characterization tests...
});
```

**Deliverable:**
- [ ] 15-20 characterization tests covering existing behavior
- [ ] All tests passing (green bar)

#### Step 2.2: Extract Domain Entity

**Create rich domain model with business logic:**

```typescript
// server/domain/entities/CertificationApplication.ts

export class CertificationApplication {
  private constructor(
    readonly id: string,
    private _vendorId: string,
    private _tierRequested: CertificationTier,
    private _documentation: Documentation,
    private _compliance: ComplianceStatements,
    private _checks: CertificationChecks,
    private _testResults: TestResults | null
  ) {}

  // Factory method
  static create(
    vendorId: string,
    tier: CertificationTier,
    documentation: Documentation,
    compliance: ComplianceStatements
  ): CertificationApplication {
    // Domain validation
    if (!tier.isValid()) {
      throw new InvalidCertificationTierError(tier);
    }

    return new CertificationApplication(
      generateId(),
      vendorId,
      tier,
      documentation,
      compliance,
      CertificationChecks.initial(),
      null
    );
  }

  // Business logic methods
  evaluate(): EvaluationResult {
    this._checks = CertificationChecks.from({
      documentationComplete: this._documentation.meetsRequirements(this._tierRequested),
      complianceValid: this._compliance.meetsRequirements(this._tierRequested),
      deploymentHistoryValid: this._tierRequested.deploymentRequirementsMet(this._vendorId)
    });

    return new EvaluationResult(
      this.calculateScore(),
      this._checks,
      this.generateRecommendations()
    );
  }

  applyTestResults(results: TestResults): void {
    this._testResults = results;
    this._checks = this._checks.updateFromTests(results);
  }

  calculateScore(): number {
    const weights = CertificationScoring.getWeights();
    return this._checks.calculateWeightedScore(weights);
  }

  hasPassedEvaluation(): boolean {
    return this._checks.allChecksPassed() &&
           this.calculateScore() >= this._tierRequested.minimumScore();
  }

  private generateRecommendations(): string[] {
    const recommendations: string[] = [];

    if (!this._checks.documentationComplete) {
      recommendations.push(
        this._tierRequested.documentationRequirementMessage()
      );
    }

    // More business logic for recommendations...

    return recommendations;
  }

  // Domain events
  collectEvents(): DomainEvent[] {
    return this._domainEvents;
  }
}
```

**Value Objects:**

```typescript
// server/domain/value-objects/CertificationTier.ts

export class CertificationTier {
  private constructor(private readonly value: 'Silver' | 'Gold' | 'Platinum') {}

  static Silver = new CertificationTier('Silver');
  static Gold = new CertificationTier('Gold');
  static Platinum = new CertificationTier('Platinum');

  static fromString(tier: string): CertificationTier {
    switch (tier) {
      case 'Silver': return CertificationTier.Silver;
      case 'Gold': return CertificationTier.Gold;
      case 'Platinum': return CertificationTier.Platinum;
      default: throw new InvalidCertificationTierError(tier);
    }
  }

  minimumScore(): number {
    switch (this.value) {
      case 'Silver': return 40;
      case 'Gold': return 70;
      case 'Platinum': return 90;
    }
  }

  requiredDocuments(): number {
    switch (this.value) {
      case 'Silver': return 1;
      case 'Gold': return 2;
      case 'Platinum': return 3;
    }
  }

  deploymentRequirementsMet(vendorId: string): boolean {
    // Would call repository to check deployments
    // This is where we'd inject repository if needed
  }
}
```

**Deliverable:**
- [ ] CertificationApplication entity with business logic
- [ ] CertificationTier value object
- [ ] Unit tests for entity (90%+ coverage)

#### Step 2.3: Create Repository Interface

```typescript
// server/domain/repositories/CertificationApplicationRepository.ts

export interface CertificationApplicationRepository {
  findById(id: string): Promise<CertificationApplication | null>;
  save(application: CertificationApplication): Promise<void>;
  findByVendor(vendorId: string): Promise<CertificationApplication[]>;
}
```

**Implementation:**

```typescript
// server/infrastructure/repositories/DrizzleCertificationApplicationRepository.ts

export class DrizzleCertificationApplicationRepository
  implements CertificationApplicationRepository {

  constructor(private db: DrizzleDB) {}

  async findById(id: string): Promise<CertificationApplication | null> {
    const rows = await this.db
      .select()
      .from(certificationApplications)
      .where(eq(certificationApplications.id, id));

    if (rows.length === 0) return null;

    return this.toDomainEntity(rows[0]);
  }

  async save(application: CertificationApplication): Promise<void> {
    const data = this.toDataModel(application);

    await this.db
      .insert(certificationApplications)
      .values(data)
      .onConflictDoUpdate({
        target: certificationApplications.id,
        set: data
      });
  }

  private toDomainEntity(row: CertificationApplicationRow): CertificationApplication {
    // Map database row to domain entity
    return CertificationApplication.reconstitute(
      row.id,
      row.vendor_id,
      CertificationTier.fromString(row.tier_requested),
      // ... more mapping
    );
  }

  private toDataModel(application: CertificationApplication): CertificationApplicationRow {
    // Map domain entity to database row
    return {
      id: application.id,
      vendor_id: application.vendorId,
      tier_requested: application.tierRequested.toString(),
      // ... more mapping
    };
  }
}
```

**Deliverable:**
- [ ] Repository interface in domain
- [ ] Repository implementation in infrastructure
- [ ] Integration tests for repository

#### Step 2.4: Create Use Case

```typescript
// server/application/certifications/ProcessApplication.ts

export class ProcessApplicationRequest {
  constructor(readonly applicationId: string) {}
}

export class ProcessApplicationResponse {
  constructor(
    readonly passed: boolean,
    readonly score: number,
    readonly checks: CertificationChecksView,
    readonly recommendations: string[]
  ) {}

  static fromEvaluationResult(result: EvaluationResult): ProcessApplicationResponse {
    return new ProcessApplicationResponse(
      result.passed,
      result.score,
      CertificationChecksView.fromDomain(result.checks),
      result.recommendations
    );
  }
}

export class ProcessCertificationApplicationUseCase {
  constructor(
    private applicationRepo: CertificationApplicationRepository,
    private testingGateway: VendorTestingGateway
  ) {}

  async execute(request: ProcessApplicationRequest): Promise<ProcessApplicationResponse> {
    // 1. Load aggregate
    const application = await this.applicationRepo.findById(request.applicationId);
    if (!application) {
      throw new ApplicationNotFoundError(request.applicationId);
    }

    // 2. Run evaluation (domain logic in entity)
    const evaluationResult = application.evaluate();

    // 3. Run external tests (infrastructure gateway)
    const testResults = await this.testingGateway.runAllTests({
      applicationId: request.applicationId,
      vendorId: application.vendorId
    });

    // 4. Apply test results (domain logic in entity)
    application.applyTestResults(testResults);

    // 5. Persist
    await this.applicationRepo.save(application);

    // 6. Return response
    return ProcessApplicationResponse.fromEvaluationResult(evaluationResult);
  }
}
```

**Deliverable:**
- [ ] Use case with request/response models
- [ ] Integration tests for use case (mocked repository)

#### Step 2.5: Update Route (Thin Controller)

```typescript
// server/frameworks/http/routes/certifications.ts

export function registerCertificationRoutes(app: Express) {
  app.post('/api/certifications/:id/process', requireAuth, async (req, res) => {
    try {
      // 1. Create request from HTTP input
      const request = new ProcessApplicationRequest(req.params.id);

      // 2. Execute use case (all logic delegated)
      const response = await processCertificationUseCase.execute(request);

      // 3. Return HTTP response
      res.status(200).json(response);
    } catch (error) {
      if (error instanceof ApplicationNotFoundError) {
        return res.status(404).json({ error: error.message });
      }
      throw error;
    }
  });
}
```

**Deliverable:**
- [ ] Updated route (thin, delegates to use case)
- [ ] Existing tests still passing

#### Step 2.6: Parallel Implementation & Cutover

**Strategy:** Run both old and new implementations side-by-side, compare results

```typescript
// Feature flag for gradual rollout
const USE_NEW_CERTIFICATION_FLOW = process.env.USE_NEW_CERTIFICATION === 'true';

app.post('/api/certifications/:id/process', requireAuth, async (req, res) => {
  if (USE_NEW_CERTIFICATION_FLOW) {
    // New implementation (Clean Architecture)
    const request = new ProcessApplicationRequest(req.params.id);
    const response = await processCertificationUseCase.execute(request);
    return res.status(200).json(response);
  } else {
    // Old implementation (keep for now)
    const result = await processCertificationApplication(req.params.id);
    return res.status(200).json(result);
  }
});
```

**Validation:**
1. Deploy with feature flag OFF (old implementation)
2. Run comparison script (call both, compare results)
3. Fix discrepancies
4. Enable feature flag for 10% of requests (canary)
5. Monitor for errors
6. Roll out to 50%, then 100%
7. Remove old implementation

**Deliverable:**
- [ ] Feature flag implemented
- [ ] Comparison tests passing
- [ ] Cutover completed
- [ ] Old code removed

#### Phase 2 Deliverables Summary

- [x] Characterization tests (safety net)
- [x] Domain entity with business logic
- [x] Repository pattern implemented
- [x] Use case orchestrating workflow
- [x] Thin controller in framework layer
- [x] All tests passing
- [x] Feature deployed to production
- [x] Team trained on Clean Architecture

**Duration:** 2 weeks
**Risk:** Medium (pilot project, learning phase)

---

### Phase 3: Expand to P1 Features (Weeks 5-8)

**Goal:** Refactor high-priority business capabilities using lessons from pilot.

**Priority Order (by business criticality):**

#### Story 1: Policy Enforcement (Week 5-6)

**Current:** `policy-enforcement-engine.ts` (620 lines, mixed concerns)

**Refactor to:**

```
Domain:
‚îú‚îÄ‚îÄ Policy entity (evaluation logic)
‚îú‚îÄ‚îÄ AISystem entity (risk assessment)
‚îú‚îÄ‚îÄ PolicyRule value object
‚îî‚îÄ‚îÄ PolicyEvaluator domain service

Application:
‚îú‚îÄ‚îÄ EvaluateAISystemUseCase
‚îú‚îÄ‚îÄ CreatePolicyUseCase
‚îî‚îÄ‚îÄ ResolvePolicyViolationUseCase

Infrastructure:
‚îú‚îÄ‚îÄ PolicyRepository
‚îú‚îÄ‚îÄ PolicyViolationRepository
‚îî‚îÄ‚îÄ AlertGateway (Slack/email notifications)

Framework:
‚îî‚îÄ‚îÄ POST /api/policies/:id/evaluate (thin)
```

**Business Value:** Critical for compliance, high usage feature

#### Story 2: Billing & Subscriptions (Week 6-7)

**Current:** `stripe-billing.ts` (400+ lines)

**Refactor to:**

```
Domain:
‚îú‚îÄ‚îÄ Subscription entity (usage limits, billing cycles)
‚îú‚îÄ‚îÄ BillingAccount entity
‚îú‚îÄ‚îÄ SubscriptionTier value object
‚îî‚îÄ‚îÄ UsageValidator domain service

Application:
‚îú‚îÄ‚îÄ CreateHealthSystemSubscriptionUseCase
‚îú‚îÄ‚îÄ CreateVendorSubscriptionUseCase
‚îú‚îÄ‚îÄ CheckUsageLimitsUseCase
‚îî‚îÄ‚îÄ HandleSubscriptionWebhookUseCase

Infrastructure:
‚îú‚îÄ‚îÄ SubscriptionRepository
‚îú‚îÄ‚îÄ StripeGateway (payment processing)
‚îî‚îÄ‚îÄ WebhookValidator

Framework:
‚îî‚îÄ‚îÄ POST /api/billing/subscriptions/* (thin)
```

**Business Value:** Revenue-critical feature

#### Story 3: AI System Registration (Week 7-8)

**Current:** Mixed across routes and services

**Refactor to:**

```
Domain:
‚îú‚îÄ‚îÄ AISystem entity (validation, state transitions)
‚îú‚îÄ‚îÄ RiskLevel value object
‚îú‚îÄ‚îÄ SystemStatus value object
‚îî‚îÄ‚îÄ DeploymentPolicy domain service

Application:
‚îú‚îÄ‚îÄ RegisterAISystemUseCase
‚îú‚îÄ‚îÄ UpdateAISystemUseCase
‚îú‚îÄ‚îÄ DeployAISystemUseCase
‚îî‚îÄ‚îÄ DeactivateAISystemUseCase

Infrastructure:
‚îú‚îÄ‚îÄ AISystemRepository
‚îú‚îÄ‚îÄ EpicFHIRGateway (sync from EHR)
‚îî‚îÄ‚îÄ TelemetryGateway (monitoring)

Framework:
‚îî‚îÄ‚îÄ POST /api/ai-systems (thin)
```

**Business Value:** Core platform functionality

#### Phase 3 Deliverables

- [ ] Policy enforcement refactored
- [ ] Billing & subscriptions refactored
- [ ] AI system registration refactored
- [ ] 80%+ test coverage for these features
- [ ] Feature flags removed (stable in production)
- [ ] Documentation updated

**Duration:** 4 weeks
**Risk:** Medium (building on pilot learnings)

---

### Phase 4: Infrastructure Refactoring (Weeks 9-10)

**Goal:** Consolidate infrastructure layer, complete repository pattern adoption.

#### Task 4.1: Extract All Repositories

**Replace:** `storage.ts` singleton with repository pattern

**Create repositories for each aggregate:**

```
infrastructure/repositories/
‚îú‚îÄ‚îÄ DrizzleUserRepository.ts
‚îú‚îÄ‚îÄ DrizzleHealthSystemRepository.ts
‚îú‚îÄ‚îÄ DrizzleVendorRepository.ts
‚îú‚îÄ‚îÄ DrizzleAISystemRepository.ts
‚îú‚îÄ‚îÄ DrizzleAlertRepository.ts
‚îú‚îÄ‚îÄ DrizzleAuditLogRepository.ts
‚îî‚îÄ‚îÄ ...
```

**Update:** All use cases to inject repositories via constructor

#### Task 4.2: Extract All Gateways

**Consolidate external integrations:**

```
infrastructure/gateways/
‚îú‚îÄ‚îÄ StripeGateway.ts (billing)
‚îú‚îÄ‚îÄ EpicFHIRGateway.ts (EHR sync)
‚îú‚îÄ‚îÄ ArizeGateway.ts (ML monitoring)
‚îú‚îÄ‚îÄ LangSmithGateway.ts (LLM tracing)
‚îú‚îÄ‚îÄ EmailGateway.ts (SendGrid)
‚îú‚îÄ‚îÄ SMSGateway.ts (Twilio)
‚îú‚îÄ‚îÄ SlackGateway.ts (notifications)
‚îî‚îÄ‚îÄ S3Gateway.ts (file storage)
```

**Define interfaces in domain/application, implement in infrastructure**

#### Task 4.3: Service Consolidation

**Merge related services:**

1. **Notification Services** ‚Üí Single `NotificationGateway`
   - Combine: `email-notification.ts`, `sms-notification.ts`, `slack-notification.ts`

2. **Encryption Services** ‚Üí Single `EncryptionService`
   - Combine: `encryption.ts`, `phi-encryption.ts`, `policy-encryption.ts`

3. **Testing Services** ‚Üí `VendorTestingGateway`
   - Extract domain logic to entities, keep infrastructure in gateway

#### Phase 4 Deliverables

- [ ] All repositories extracted and injected
- [ ] All gateways abstracted with interfaces
- [ ] Related services consolidated
- [ ] storage.ts singleton removed
- [ ] Dependency injection configured
- [ ] All tests passing

**Duration:** 2 weeks
**Risk:** Low (no behavior changes)

---

### Phase 5: Testing Implementation (Weeks 11-12)

**Goal:** Achieve 80% test coverage for refactored modules.

#### Test Strategy: Testing Pyramid

```
        /\
       /E2E\      ‚Üê 5-10 tests (critical user flows)
      /------\
     /  Integ \   ‚Üê 50-100 tests (use cases + repos)
    /----------\
   /    Unit    \ ‚Üê 200+ tests (entities, value objects)
  /              \
```

#### Unit Tests (Domain Layer) - MOST

**Test entities and value objects in complete isolation:**

```typescript
// tests/unit/domain/entities/CertificationApplication.test.ts

describe('CertificationApplication', () => {
  describe('calculateScore', () => {
    it('should award 20 points for complete documentation', () => {
      const application = CertificationApplication.create(
        'vendor-1',
        CertificationTier.Silver,
        Documentation.complete(['doc1.pdf']),
        ComplianceStatements.hipaaOnly()
      );

      application.evaluate();
      const score = application.calculateScore();

      expect(score).toBe(40); // 20 (docs) + 20 (compliance)
    });

    it('should require 70+ score for Gold tier', () => {
      const application = CertificationApplication.create(
        'vendor-1',
        CertificationTier.Gold,
        Documentation.minimal(),
        ComplianceStatements.hipaaOnly()
      );

      const result = application.evaluate();

      expect(result.passed).toBe(false);
      expect(application.calculateScore()).toBeLessThan(70);
    });
  });

  describe('applyTestResults', () => {
    it('should update checks based on test results', () => {
      const application = createSampleApplication();
      const testResults = TestResults.allPassed();

      application.applyTestResults(testResults);

      expect(application.hasPassedEvaluation()).toBe(true);
    });
  });
});
```

**Characteristics:**
- ‚úÖ Fast (milliseconds)
- ‚úÖ No dependencies (no database, no HTTP)
- ‚úÖ Pure logic testing
- ‚úÖ Easy to maintain

**Coverage Goal:** 90%+ for all domain entities and value objects

#### Integration Tests (Application Layer) - MEDIUM

**Test use cases with mocked infrastructure:**

```typescript
// tests/integration/application/ProcessCertificationApplication.test.ts

describe('ProcessCertificationApplicationUseCase', () => {
  let useCase: ProcessCertificationApplicationUseCase;
  let mockRepo: MockCertificationApplicationRepository;
  let mockGateway: MockVendorTestingGateway;

  beforeEach(() => {
    mockRepo = new MockCertificationApplicationRepository();
    mockGateway = new MockVendorTestingGateway();
    useCase = new ProcessCertificationApplicationUseCase(mockRepo, mockGateway);
  });

  it('should process application and save result', async () => {
    // Arrange
    const application = createSampleApplication();
    mockRepo.setApplication(application);
    mockGateway.setTestResults(TestResults.allPassed());

    // Act
    const response = await useCase.execute(
      new ProcessApplicationRequest(application.id)
    );

    // Assert
    expect(response.passed).toBe(true);
    expect(mockRepo.saveWasCalled).toBe(true);
  });

  it('should throw error if application not found', async () => {
    mockRepo.setApplication(null);

    await expect(
      useCase.execute(new ProcessApplicationRequest('invalid-id'))
    ).rejects.toThrow(ApplicationNotFoundError);
  });
});
```

**Characteristics:**
- ‚ö° Medium speed (seconds)
- üé≠ Mocked infrastructure (in-memory repositories)
- üîÑ Tests orchestration logic
- üì¶ Tests use case workflows

**Coverage Goal:** 80%+ for all use cases

#### E2E Tests (Framework Layer) - FEWEST

**Test complete user workflows through HTTP API:**

```typescript
// tests/e2e/certification-flow.test.ts

describe('Certification Application Flow (E2E)', () => {
  let app: Express;
  let testDb: TestDatabase;

  beforeAll(async () => {
    testDb = await TestDatabase.create();
    app = createTestApp(testDb);
  });

  afterAll(async () => {
    await testDb.teardown();
  });

  it('should process certification application end-to-end', async () => {
    // 1. Vendor creates certification application
    const createResponse = await request(app)
      .post('/api/certifications')
      .send({
        vendorId: 'vendor-1',
        tierRequested: 'Silver',
        documentationUrls: ['https://example.com/hipaa.pdf'],
        complianceStatements: { hipaa: true }
      })
      .expect(201);

    const applicationId = createResponse.body.id;

    // 2. Process application
    const processResponse = await request(app)
      .post(`/api/certifications/${applicationId}/process`)
      .expect(200);

    // 3. Verify result
    expect(processResponse.body.passed).toBe(true);
    expect(processResponse.body.score).toBeGreaterThanOrEqual(40);

    // 4. Verify database state
    const application = await testDb.query(
      'SELECT * FROM certification_applications WHERE id = ?',
      [applicationId]
    );
    expect(application.status).toBe('in_review');
  });
});
```

**Characteristics:**
- üêå Slow (seconds to minutes)
- üåê Real HTTP requests
- üóÑÔ∏è Real database (test container)
- üéØ Tests critical happy paths

**Coverage Goal:** 5-10 critical user flows

#### Phase 5 Deliverables

- [ ] 200+ unit tests (domain layer)
- [ ] 50+ integration tests (application layer)
- [ ] 5-10 E2E tests (critical flows)
- [ ] 80%+ overall code coverage
- [ ] CI/CD pipeline running tests
- [ ] Test documentation

**Duration:** 2 weeks
**Risk:** Low (adds safety, no behavior changes)

---

### Phase 6: Remaining Features (Weeks 13+)

**Goal:** Complete refactoring for all business capabilities.

#### P2 Stories (Medium Priority)

**Week 13-14: Compliance Reporting**
- Domain: ComplianceReport entity, ControlEvaluation value object
- Application: GenerateComplianceReportUseCase
- Infrastructure: ReportRepository, ReportGenerator

**Week 15-16: Vendor Performance Tracking**
- Domain: VendorPerformance entity, PerformanceMetrics value object
- Application: TrackVendorPerformanceUseCase
- Infrastructure: PerformanceRepository, MetricsCollector

**Week 17-18: Network Metrics**
- Domain: NetworkMetrics entity, VendorReach value object
- Application: CalculateNetworkMetricsUseCase
- Infrastructure: MetricsRepository

**Week 19-20: Analytics & Dashboards**
- Domain: Analytics domain service (calculations)
- Application: GetDashboardDataUseCase
- Infrastructure: AnalyticsRepository (read models)

#### P3 Stories (Lower Priority)

**As time permits:**
- Background jobs refactoring (Inngest workflows)
- Telemetry polling optimization
- Audit log improvements
- ROI metrics calculation

#### Phase 6 Deliverables

- [ ] All P2 features refactored
- [ ] P3 features refactored (if time allows)
- [ ] 80%+ test coverage maintained
- [ ] All feature flags removed
- [ ] Old code deleted
- [ ] Architecture documentation complete

**Duration:** 8+ weeks (adjust based on velocity)
**Risk:** Low (well-established patterns by this point)

---

## Refactoring Guidelines & Best Practices

### DO's ‚úÖ

1. **Refactor one feature at a time (vertical slices)**
   - Complete all layers before moving to next feature
   - Validate each feature works before proceeding

2. **Write tests BEFORE refactoring (characterization tests)**
   - Lock in existing behavior
   - Create safety net for changes
   - Catch regressions immediately

3. **Keep existing code working (parallel implementation)**
   - Run old and new side-by-side
   - Use feature flags for gradual cutover
   - Compare outputs to validate correctness

4. **Extract incrementally (strangler fig pattern)**
   - Wrap old code with new interfaces
   - Gradually replace internals
   - Remove old code only when confident

5. **Use feature flags for risky changes**
   - Enable for small percentage of traffic
   - Monitor errors and performance
   - Roll back quickly if issues arise

6. **Document architectural decisions (ADRs)**
   - Record why decisions were made
   - Help future developers understand context
   - Track evolution of architecture

7. **Pair program on refactoring**
   - Share knowledge across team
   - Catch issues early
   - Build collective ownership

8. **Review code at each checkpoint**
   - Ensure patterns are consistent
   - Catch violations of layer boundaries
   - Maintain code quality

### DON'Ts ‚ùå

1. **Don't rewrite everything at once**
   - Too risky, too much can go wrong
   - Hard to test and validate
   - Delays value delivery

2. **Don't skip testing (no tests = dangerous refactoring)**
   - Tests are your safety net
   - Without tests, you're flying blind
   - Regressions will happen

3. **Don't break existing functionality**
   - Users depend on current behavior
   - Business cannot tolerate downtime
   - Refactoring should be transparent to users

4. **Don't mix refactoring with new features**
   - Conflates risk (is bug from refactor or new feature?)
   - Harder to review and test
   - Slows down both activities

5. **Don't ignore performance implications**
   - Abstractions can add overhead
   - Monitor metrics during refactoring
   - Optimize if needed (but don't prematurely)

6. **Don't let perfect be enemy of good**
   - 80% Clean Architecture is better than 0%
   - Incremental improvement over time
   - Pragmatism over purism

7. **Don't force Clean Architecture where it doesn't fit**
   - Simple CRUD doesn't need use cases
   - Not every service needs a repository
   - Apply patterns judiciously

8. **Don't forget to delete old code**
   - Once cutover is complete, remove old implementation
   - Reduces maintenance burden
   - Eliminates confusion

---

## Success Metrics

### Architectural Health Indicators

**Layer Separation:**
- [ ] 100% of P1 features have domain entities
- [ ] 100% of P1 features have use cases
- [ ] 0 direct database access in routes
- [ ] 0 business logic in framework layer
- [ ] Repository pattern for all data access
- [ ] Dependencies flow inward (no violations)

**Code Quality:**
- [ ] 80%+ test coverage (unit + integration)
- [ ] <500 lines per service file
- [ ] <10 dependencies per module
- [ ] ESLint architectural rules passing
- [ ] 0 circular dependencies

**Team Velocity:**
- [ ] No regression bugs from refactoring
- [ ] Feature development continues during refactor
- [ ] Pull request review time <24 hours
- [ ] Onboarding time for new developers reduced

**Business Continuity:**
- [ ] 99.9%+ uptime maintained
- [ ] No customer-reported issues from refactoring
- [ ] Performance metrics stable or improved
- [ ] Support tickets related to bugs declining

### Tracking & Reporting

**Weekly Status Report:**
```markdown
## Week [X] Refactoring Status

### Completed:
- [x] Feature X refactored (domain + application + infra)
- [x] Test coverage: 85%
- [x] Deployed to production (feature flag 100%)

### In Progress:
- [ ] Feature Y - domain layer (70% complete)

### Blockers:
- None

### Metrics:
- Lines of code: 15,234 (-500 from last week)
- Test coverage: 72% (+8% from last week)
- Build time: 2m 15s (stable)
- Deployment success rate: 100%

### Next Week:
- Complete Feature Y
- Start Feature Z
```

---

## Risk Management

### Identified Risks & Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **Breaking existing functionality** | High | Critical | ‚Ä¢ Write characterization tests first<br>‚Ä¢ Parallel implementation with comparison<br>‚Ä¢ Feature flags for gradual rollout |
| **Performance degradation** | Medium | High | ‚Ä¢ Monitor metrics continuously<br>‚Ä¢ Load testing before full rollout<br>‚Ä¢ Optimize hotspots if needed |
| **Team velocity slowdown** | Medium | Medium | ‚Ä¢ Training on Clean Architecture<br>‚Ä¢ Pair programming for knowledge sharing<br>‚Ä¢ Clear examples and patterns |
| **Scope creep** | Medium | Medium | ‚Ä¢ Stick to vertical slices<br>‚Ä¢ Don't add new features during refactoring<br>‚Ä¢ Time-box each phase |
| **Incomplete refactoring** | Low | Medium | ‚Ä¢ Prioritize P1 features<br>‚Ä¢ P2/P3 are optional<br>‚Ä¢ Document what remains |
| **Resistance to change** | Low | Low | ‚Ä¢ Communicate benefits clearly<br>‚Ä¢ Show incremental value<br>‚Ä¢ Celebrate wins |

### Rollback Plan

**If issues arise during cutover:**

1. **Immediate:** Disable feature flag (revert to old implementation)
2. **Investigate:** Analyze logs, metrics, error reports
3. **Fix:** Address issue in new implementation
4. **Re-validate:** Test thoroughly in staging
5. **Re-deploy:** Gradual rollout again (10% ‚Üí 50% ‚Üí 100%)

**Feature flag implementation:**
```typescript
const USE_NEW_IMPLEMENTATION = getFeatureFlag('new-certification-flow', req.session.userId);

if (USE_NEW_IMPLEMENTATION) {
  // New Clean Architecture implementation
} else {
  // Old implementation (safety fallback)
}
```

---

## Effort Estimate

### Timeline Summary

| Phase | Duration | Risk Level | Business Value |
|-------|----------|------------|----------------|
| **Phase 1:** Foundation Setup | 2 weeks | Low | Foundation for all future work |
| **Phase 2:** Pilot Refactor (Certification) | 2 weeks | Medium | Validate approach, train team |
| **Phase 3:** P1 Features | 4 weeks | Medium | High business value features |
| **Phase 4:** Infrastructure | 2 weeks | Low | Clean up technical debt |
| **Phase 5:** Testing | 2 weeks | Low | Safety net for future changes |
| **Phase 6:** P2/P3 Features | 8+ weeks | Low | Complete the refactoring |

**Total Duration:** 20+ weeks (5+ months) with 1-2 engineers dedicated

### Resource Requirements

**Team Composition:**
- 1-2 Engineers (80% time dedicated to refactoring)
- 1 Tech Lead (20% time for architecture guidance and review)
- 1 QA Engineer (20% time for testing strategy)

**External Resources:**
- Clean Architecture training/workshop (1-2 days)
- Code review from external architect (optional, 2-3 sessions)

### Cost-Benefit Analysis

**Costs:**
- 5 months of engineering time
- Potential for bugs during refactoring (mitigated by testing)
- Temporary slowdown in feature development

**Benefits:**
- **Testability:** 80%+ test coverage enables confident changes
- **Maintainability:** Clear structure reduces cognitive load, faster onboarding
- **Scalability:** Add features without touching infrastructure
- **Quality:** Fewer bugs from well-tested, isolated business logic
- **Velocity:** Faster feature development long-term (6+ months out)
- **Team morale:** Modern architecture attracts and retains talent

**Break-even:** Estimated 9-12 months (when accumulated velocity gains offset refactoring cost)

---

## Recommendations

### Immediate Actions (Week 1)

1. ‚úÖ **Present this assessment** to engineering team and leadership for alignment
2. ‚úÖ **Set up testing framework** (Vitest) and write first sample test
3. ‚úÖ **Create directory structure** for new layers (domain, application, infrastructure)
4. ‚úÖ **Choose pilot feature** (recommend: Certification flow)
5. ‚úÖ **Write characterization tests** for pilot feature to create safety net

### Strategic Decisions Needed

Before starting Phase 2, answer these questions:

1. **Refactoring Pace:**
   - [ ] Dedicated time (1-2 engineers full-time on refactoring)?
   - [ ] Parallel development (refactoring alongside feature work)?
   - **Recommendation:** Dedicated time for Phase 2-3, then parallel

2. **Team Training:**
   - [ ] Workshop on Clean Architecture patterns (1-2 days)?
   - [ ] Pair programming on first feature?
   - [ ] External consultant for guidance?
   - **Recommendation:** Workshop + pair programming

3. **Tooling & Automation:**
   - [ ] ESLint plugins for architecture enforcement?
   - [ ] Automated dependency checks in CI?
   - [ ] Test coverage requirements?
   - **Recommendation:** All of the above (invest in quality gates)

4. **Documentation:**
   - [ ] ADRs (Architecture Decision Records) for major changes?
   - [ ] Updated onboarding docs?
   - [ ] Code examples and patterns?
   - **Recommendation:** ADRs for each phase, examples in repo

5. **Communication:**
   - [ ] Weekly status updates to stakeholders?
   - [ ] Monthly demos of refactored features?
   - [ ] Retrospectives after each phase?
   - **Recommendation:** All of the above (transparency builds trust)

### Long-Term Vision

**After refactoring is complete, the architecture will enable:**

‚úÖ **Testability**
- Unit test domain logic in isolation (milliseconds)
- Integration test use cases with mocked infrastructure
- High confidence in changes

‚úÖ **Maintainability**
- Clear boundaries reduce cognitive load
- New developers understand structure quickly
- Easy to find where business logic lives

‚úÖ **Scalability**
- Add features without touching infrastructure
- Swap databases/frameworks with confidence
- Handle growth without architectural rewrite

‚úÖ **Team Growth**
- Modern architecture attracts talent
- Clear patterns enable parallel development
- Reduced onboarding time (days instead of weeks)

‚úÖ **Business Agility**
- Faster feature delivery (lower bug rate)
- Confident experimentation (rollback easily)
- Compliance-ready (audit trail, testability)

---

## Appendix

### A. Glossary

**Clean Architecture Terms:**

- **Entity:** Core business object with identity and behavior (e.g., CertificationApplication)
- **Value Object:** Immutable object defined by its attributes (e.g., CertificationTier, RiskLevel)
- **Aggregate:** Cluster of entities treated as a single unit (e.g., Order with OrderItems)
- **Repository:** Abstraction for persisting and retrieving aggregates
- **Use Case:** Application-specific business logic coordinating domain objects
- **Gateway:** Abstraction for external service integrations
- **Domain Service:** Stateless service for business logic spanning multiple entities
- **Domain Event:** Record of something that happened in the domain

**Architecture Concepts:**

- **Dependency Rule:** Dependencies always point inward (outer layers depend on inner)
- **Vertical Slicing:** Implementing one user story through all layers before moving to next
- **Layer Sanctity:** Maintaining strict boundaries between layers
- **Anemic Domain Model:** Anti-pattern where entities have no behavior (just data)
- **God Service:** Anti-pattern where one service does too many things

### B. Reference Architecture Diagram

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      FRAMEWORKS LAYER                            ‚îÇ
‚îÇ  (HTTP Routes, Controllers, Middleware)                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ  ‚îÇ  Express   ‚îÇ  ‚îÇ    Auth    ‚îÇ  ‚îÇ   CSRF     ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ  Routes    ‚îÇ  ‚îÇ Middleware ‚îÇ  ‚îÇ Protection ‚îÇ                ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îÇ                         ‚Üì                                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                    APPLICATION LAYER                             ‚îÇ
‚îÇ  (Use Cases, Request/Response Models, Views)                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  CreateSubscriptionUseCase                                 ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ProcessCertificationUseCase                               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  EvaluateAISystemUseCase                                   ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                         ‚Üì                                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                      DOMAIN LAYER                                ‚îÇ
‚îÇ  (Entities, Value Objects, Domain Services, Repository Interfaces)‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ  ‚îÇSubscription‚îÇ  ‚îÇ AISystem   ‚îÇ  ‚îÇ   Policy   ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ  Entity    ‚îÇ  ‚îÇ  Entity    ‚îÇ  ‚îÇ   Entity   ‚îÇ                ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  Repository Interfaces (ISubscriptionRepository, etc.)     ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                         ‚Üë                                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                  INFRASTRUCTURE LAYER                            ‚îÇ
‚îÇ  (Repository Implementations, Gateways, External Services)       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ  ‚îÇ  Drizzle   ‚îÇ  ‚îÇ   Stripe   ‚îÇ  ‚îÇ    Epic    ‚îÇ                ‚îÇ
‚îÇ  ‚îÇRepositories‚îÇ  ‚îÇ  Gateway   ‚îÇ  ‚îÇ    FHIR    ‚îÇ                ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ  ‚îÇ PostgreSQL ‚îÇ  ‚îÇ  SendGrid  ‚îÇ  ‚îÇ    AWS     ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ  Database  ‚îÇ  ‚îÇ   Email    ‚îÇ  ‚îÇ     S3     ‚îÇ                ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Dependency Flow: Outer ‚Üí Inner (arrows point inward)
```

### C. Example File Structure

```
shane-prototype/
‚îú‚îÄ‚îÄ client/                     # Frontend (React) - NO CHANGES
‚îú‚îÄ‚îÄ shared/
‚îÇ   ‚îî‚îÄ‚îÄ schema.ts              # Database schema (Drizzle) - keep for now
‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îú‚îÄ‚îÄ domain/                # NEW - Core business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AISystem.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CertificationApplication.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Policy.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Subscription.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ User.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ value-objects/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CertificationTier.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Email.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Money.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RiskLevel.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SystemStatus.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repositories/      # Interfaces only
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AISystemRepository.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CertificationApplicationRepository.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PolicyRepository.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SubscriptionRepository.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/          # Domain services (pure logic)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PolicyEvaluator.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RiskAssessor.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ events/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ DomainEvent.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ SystemDeployedEvent.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ CertificationApprovedEvent.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ application/           # NEW - Use cases
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ billing/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateHealthSystemSubscription.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CheckUsageLimits.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Views.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ certifications/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProcessApplication.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ApproveApplication.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Views.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ policies/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreatePolicy.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EvaluateAISystem.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Views.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ai-systems/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ RegisterAISystem.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ DeployAISystem.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ Views.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/        # REORGANIZE EXISTING
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repositories/      # Implementations
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DrizzleAISystemRepository.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DrizzleCertificationRepository.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DrizzlePolicyRepository.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DrizzleSubscriptionRepository.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gateways/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StripeGateway.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EpicFHIRGateway.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EmailGateway.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ VendorTestingGateway.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ encryption/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ EncryptionService.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ persistence/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ db.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ migrations/
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ frameworks/            # RENAME FROM routes/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ http/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ billing.ts
‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ certifications.ts
‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ policies.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ controllers/   # NEW - thin controllers
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ middleware/    # Existing middleware
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ services/              # LEGACY - gradually remove
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [old service files to be refactored]
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ storage.ts             # LEGACY - replace with repositories
‚îÇ   ‚îú‚îÄ‚îÄ db.ts                  # Move to infrastructure/persistence/
‚îÇ   ‚îú‚îÄ‚îÄ cache.ts               # Infrastructure layer
‚îÇ   ‚îú‚îÄ‚îÄ logger.ts              # Infrastructure layer
‚îÇ   ‚îî‚îÄ‚îÄ index.ts               # Application entry point
‚îÇ
‚îú‚îÄ‚îÄ tests/                     # NEW - Test suites
‚îÇ   ‚îú‚îÄ‚îÄ unit/                  # Domain layer tests
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ value-objects/
‚îÇ   ‚îú‚îÄ‚îÄ integration/           # Application layer tests
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ application/
‚îÇ   ‚îî‚îÄ‚îÄ e2e/                   # End-to-end tests
‚îÇ       ‚îî‚îÄ‚îÄ workflows/
‚îÇ
‚îú‚îÄ‚îÄ ARCHITECTURE.md            # Existing - target architecture
‚îú‚îÄ‚îÄ REFACTORING_EVAL.md        # This document
‚îî‚îÄ‚îÄ ADRs/                      # NEW - Architecture Decision Records
    ‚îú‚îÄ‚îÄ 001-adopt-clean-architecture.md
    ‚îú‚îÄ‚îÄ 002-repository-pattern.md
    ‚îî‚îÄ‚îÄ 003-testing-strategy.md
```

### D. Recommended Reading

**Books:**
1. **"Clean Architecture"** by Robert C. Martin - Foundational principles
2. **"Domain-Driven Design"** by Eric Evans - Domain modeling
3. **"Implementing Domain-Driven Design"** by Vaughn Vernon - Practical DDD
4. **"Working Effectively with Legacy Code"** by Michael Feathers - Refactoring strategies

**Articles:**
1. [Clean Architecture with TypeScript](https://khalilstemmler.com/articles/software-design-architecture/organizing-app-logic/)
2. [The Clean Architecture (Uncle Bob)](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
3. [Anemic Domain Model (Martin Fowler)](https://martinfowler.com/bliki/AnemicDomainModel.html)

**Videos:**
1. [Clean Architecture and Design (Uncle Bob)](https://www.youtube.com/watch?v=2dKZ-dWaCiU)
2. [DDD Europe Talks](https://www.youtube.com/c/ddd_eu)

---

## Next Steps

1. **Week 1: Stakeholder Alignment**
   - Present this assessment to engineering team
   - Review with product/business stakeholders
   - Get approval on timeline and approach
   - Answer strategic questions (see section above)

2. **Week 1-2: Foundation Phase**
   - Set up testing framework (Vitest)
   - Create directory structure
   - Configure architectural fitness functions (ESLint rules)
   - Write sample test to validate setup

3. **Week 3-4: Pilot Refactor**
   - Choose pilot feature (recommend: Certification flow)
   - Write characterization tests
   - Refactor through all layers
   - Deploy with feature flag
   - Validate approach

4. **Week 5+: Expand Refactoring**
   - Apply learnings to P1 features
   - Build momentum and patterns
   - Continue through phases 3-6

5. **Ongoing: Monitor & Adjust**
   - Weekly status updates
   - Retrospectives after each phase
   - Adjust plan based on learnings
   - Celebrate wins!

---

**Document Version:** 1.0
**Last Updated:** 2025-10-27
**Author:** Architecture Assessment
**Status:** Draft for Review

---

## Approval

| Role | Name | Signature | Date |
|------|------|-----------|------|
| Engineering Lead | ________ | ________ | ________ |
| Tech Lead | ________ | ________ | ________ |
| Product Manager | ________ | ________ | ________ |
| CTO/VP Engineering | ________ | ________ | ________ |

---

**End of Document**
