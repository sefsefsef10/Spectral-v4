/**
 * ðŸ¤– AUTOMATED ACTION EXECUTION ENGINE
 * 
 * Executes automated compliance actions generated by the Translation Engine
 * Handles: rollbacks, restrictions, notifications, escalations, documentation
 */

import { logger } from "../logger";
import { storage } from "../storage";
import type { RequiredAction } from "@shared/schema";
import { sendCriticalAlertEmail } from "./email-notification";
import { sendCriticalAlertSMS } from "./sms-notification";
import { sendCriticalAlertSlack, sendComplianceViolationSlack } from "./slack-notification";

export class ActionExecutor {
  /**
   * Process all pending automated actions
   * Called by background job worker
   */
  async processPendingActions(): Promise<{ executed: number; failed: number }> {
    let executed = 0;
    let failed = 0;

    try {
      // Get all pending automated actions from all AI systems
      const allActions = await storage.getAllPendingActions();
      const automatedActions = allActions.filter((a: RequiredAction) => a.automated && a.status === 'pending');

      logger.info({ count: automatedActions.length }, `Processing ${automatedActions.length} automated action(s)`);

      for (const action of automatedActions) {
        try {
          const success = await this.executeAction(action);
          if (success) {
            // Mark action as completed
            await storage.updateRequiredActionStatus(action.id, 'completed');
            executed++;
            logger.info({ actionId: action.id, actionType: action.actionType }, `Executed automated action: ${action.actionType}`);
          } else {
            failed++;
            logger.warn({ actionId: action.id }, `Failed to execute automated action`);
          }
        } catch (actionError) {
          failed++;
          logger.error({ err: actionError, actionId: action.id }, `Error executing action`);
        }
      }

      logger.info({ executed, failed }, `Action execution batch complete: ${executed} executed, ${failed} failed`);
    } catch (error) {
      logger.error({ err: error }, "Action processor error");
    }

    return { executed, failed };
  }

  /**
   * Execute a single automated action
   */
  private async executeAction(action: RequiredAction): Promise<boolean> {
    logger.info({ actionId: action.id, actionType: action.actionType }, `Executing ${action.actionType} action`);

    switch (action.actionType) {
      case 'notify':
        return await this.executeNotify(action);
      
      case 'escalate':
        return await this.executeEscalate(action);
      
      case 'rollback':
        return await this.executeRollback(action);
      
      case 'restrict':
        return await this.executeRestrict(action);
      
      case 'document':
        return await this.executeDocument(action);
      
      default:
        logger.warn({ actionType: action.actionType }, `Unknown action type`);
        return false;
    }
  }

  /**
   * NOTIFY: Send notifications via email, SMS, and Slack
   * Returns true if: (a) at least one configured channel succeeds OR (b) all requested channels are unconfigured
   * This ensures actions complete even when optional integrations aren't set up
   */
  private async executeNotify(action: RequiredAction): Promise<boolean> {
    try {
      // Get AI system and health system details
      const aiSystem = await storage.getAISystem(action.aiSystemId);
      if (!aiSystem) {
        logger.error({ actionId: action.id }, "AI system not found for notification");
        return false;
      }

      const healthSystem = await storage.getHealthSystem(aiSystem.healthSystemId);
      if (!healthSystem) {
        logger.error({ actionId: action.id }, "Health system not found for notification");
        return false;
      }

      // Parse action details
      const details = action.actionDetails ? JSON.parse(action.actionDetails) : {};
      const notificationChannels = details.notificationChannels || ['email'];

      // Get admin users
      const orgUsers = await storage.getUsersByOrganization(aiSystem.healthSystemId);
      const adminUsers = orgUsers.filter(u => u.permissions === 'admin' && u.status === 'active');

      if (adminUsers.length === 0) {
        logger.warn({ healthSystemId: aiSystem.healthSystemId }, "No admin users found for notifications");
        return false;
      }

      // Check which channels are configured upfront
      const TWILIO_CONFIGURED = Boolean(process.env.TWILIO_ACCOUNT_SID && process.env.TWILIO_AUTH_TOKEN && process.env.TWILIO_PHONE_NUMBER);
      const SLACK_CONFIGURED = Boolean(process.env.SLACK_WEBHOOK_URL);
      const SENDGRID_CONFIGURED = Boolean(process.env.SENDGRID_API_KEY && process.env.SENDGRID_FROM_EMAIL);

      const channelResults: Record<string, { attempted: boolean; succeeded: number; skipped: boolean; failed: number; reason?: string }> = {};

      // Email notifications
      if (notificationChannels.includes('email')) {
        if (!SENDGRID_CONFIGURED) {
          channelResults.email = { attempted: false, succeeded: 0, skipped: true, failed: 0, reason: 'SendGrid not configured' };
          logger.warn("Email channel requested but SendGrid not configured");
        } else {
          channelResults.email = { attempted: true, succeeded: 0, skipped: false, failed: 0 };
          for (const admin of adminUsers) {
            try {
              await sendCriticalAlertEmail(
                admin.email,
                admin.firstName && admin.lastName 
                  ? `${admin.firstName} ${admin.lastName}`
                  : admin.username,
                {
                  aiSystemName: aiSystem.name,
                  severity: 'critical',
                  message: action.description,
                  timestamp: new Date(),
                  healthSystemName: healthSystem.name,
                  alertId: action.id,
                }
              );
              channelResults.email.succeeded++;
            } catch (emailError) {
              logger.error({ err: emailError, adminEmail: admin.email }, "Email notification runtime failure");
              channelResults.email.failed++;
            }
          }
        }
      }

      // SMS notifications
      if (notificationChannels.includes('sms')) {
        if (!TWILIO_CONFIGURED) {
          channelResults.sms = { attempted: false, succeeded: 0, skipped: true, failed: 0, reason: 'Twilio not configured' };
          logger.info("SMS channel requested but Twilio not configured - skipping");
        } else {
          channelResults.sms = { attempted: true, succeeded: 0, skipped: false, failed: 0 };
          // Would attempt SMS send here if phone numbers were available
          // For MVP: mark as skipped since user profiles don't have phone numbers yet
          channelResults.sms = { attempted: false, succeeded: 0, skipped: true, failed: 0, reason: 'User phone numbers not implemented' };
          logger.info("SMS channel configured but user phone numbers not yet implemented");
        }
      }

      // Slack notifications
      if (notificationChannels.includes('slack')) {
        if (!SLACK_CONFIGURED) {
          channelResults.slack = { attempted: false, succeeded: 0, skipped: true, failed: 0, reason: 'Slack webhook not configured' };
          logger.info("Slack channel requested but webhook not configured - skipping");
        } else {
          channelResults.slack = { attempted: true, succeeded: 0, skipped: false, failed: 0 };
          try {
            const slackResult = await sendCriticalAlertSlack({
              aiSystemName: aiSystem.name,
              healthSystemName: healthSystem.name,
              severity: 'critical',
              message: action.description,
              alertId: action.id,
              timestamp: new Date(),
            });
            
            if (slackResult) {
              channelResults.slack.succeeded++;
            } else {
              channelResults.slack.failed++;
              logger.error("Slack notification runtime failure");
            }
          } catch (slackError) {
            channelResults.slack.failed++;
            logger.error({ err: slackError }, "Slack notification runtime failure");
          }
        }
      }

      // Calculate results
      const totalSucceeded = Object.values(channelResults).reduce((sum, ch) => sum + ch.succeeded, 0);
      const totalSkipped = Object.values(channelResults).filter(ch => ch.skipped).length;
      const totalFailed = Object.values(channelResults).reduce((sum, ch) => sum + ch.failed, 0);
      const totalRequested = notificationChannels.length;

      logger.info({ 
        totalSucceeded, 
        totalSkipped, 
        totalFailed,
        totalRequested,
        channelResults 
      }, `Notification complete: ${totalSucceeded} sent, ${totalSkipped} skipped, ${totalFailed} failed of ${totalRequested} requested`);

      // Success conditions:
      // 1. At least one notification was sent successfully, OR
      // 2. All requested channels were unconfigured (skipped) - allows action to complete in partial environments
      const allRequestedChannelsSkipped = totalRequested === totalSkipped;
      const someNotificationsSent = totalSucceeded > 0;
      
      if (allRequestedChannelsSkipped) {
        logger.warn({ requestedChannels: notificationChannels }, "All requested notification channels unconfigured - marking action complete to prevent retry loop");
      }
      
      return someNotificationsSent || allRequestedChannelsSkipped;
    } catch (error) {
      logger.error({ err: error }, "Notify action failed");
      return false;
    }
  }

  /**
   * ESCALATE: Create escalation alert and notify escalation path
   */
  private async executeEscalate(action: RequiredAction): Promise<boolean> {
    try {
      const aiSystem = await storage.getAISystem(action.aiSystemId);
      if (!aiSystem) {
        return false;
      }

      // Create high-severity monitoring alert for escalation
      const alert = await storage.createAlert({
        aiSystemId: action.aiSystemId,
        type: `Escalation: ${action.description.substring(0, 50)}`,
        severity: 'high',
        message: action.description,
        resolved: false,
      });

      // Notify via escalation path
      const details = action.actionDetails ? JSON.parse(action.actionDetails) : {};
      const escalationPath = details.escalationPath || ['ciso', 'compliance_officer'];

      logger.info({ alertId: alert.id, escalationPath }, `Escalation alert created`);

      // Trigger notifications for escalation
      await this.executeNotify({
        ...action,
        actionDetails: JSON.stringify({
          notificationChannels: ['email', 'slack'],
          escalationPath,
        }),
      });

      return true;
    } catch (error) {
      logger.error({ err: error }, "Escalate action failed");
      return false;
    }
  }

  /**
   * ROLLBACK: Rollback AI system to previous version
   * NOTE: This is a simulated rollback for MVP - production would integrate with deployment systems
   */
  private async executeRollback(action: RequiredAction): Promise<boolean> {
    try {
      const details = action.actionDetails ? JSON.parse(action.actionDetails) : {};
      
      // Check if rollback requires approval
      if (details.requiresApproval) {
        logger.info({ actionId: action.id }, "Rollback requires approval - creating alert");
        
        // Create critical alert for manual approval
        await storage.createAlert({
          aiSystemId: action.aiSystemId,
          type: "ROLLBACK REQUIRED - Manual Approval",
          severity: 'critical',
          message: `URGENT: ${action.description}\n\nThis rollback requires manual approval before execution.`,
          resolved: false,
        });

        // Notify approvers
        await this.executeNotify({
          ...action,
          actionDetails: JSON.stringify({
            notificationChannels: ['email', 'sms', 'slack'],
          }),
        });

        // Mark action as requiring manual intervention
        await storage.updateRequiredActionStatus(action.id, 'in_progress');
        return false; // Don't auto-complete - needs manual approval
      }

      // For MVP: Simulate rollback by updating AI system status
      await storage.updateAISystem(action.aiSystemId, {
        status: 'rollback_pending',
      });

      // Create alert
      await storage.createAlert({
        aiSystemId: action.aiSystemId,
        type: "System Rollback Initiated",
        severity: 'high',
        message: `Automated rollback initiated: ${action.description}`,
        resolved: false,
      });

      logger.info({ aiSystemId: action.aiSystemId }, "Rollback initiated");
      return true;
    } catch (error) {
      logger.error({ err: error }, "Rollback action failed");
      return false;
    }
  }

  /**
   * RESTRICT: Restrict AI system usage
   */
  private async executeRestrict(action: RequiredAction): Promise<boolean> {
    try {
      const details = action.actionDetails ? JSON.parse(action.actionDetails) : {};
      const restrictionType = details.restrictionType || 'full_suspension';

      // Update AI system status to restricted
      await storage.updateAISystem(action.aiSystemId, {
        status: restrictionType === 'full_suspension' ? 'suspended' : 'restricted',
      });

      // Create critical alert
      await storage.createAlert({
        aiSystemId: action.aiSystemId,
        type: `AI System ${restrictionType === 'full_suspension' ? 'Suspended' : 'Restricted'}`,
        severity: 'critical',
        message: `Automated restriction applied: ${action.description}`,
        resolved: false,
      });

      // Notify stakeholders
      await this.executeNotify({
        ...action,
        actionDetails: JSON.stringify({
          notificationChannels: ['email', 'slack'],
        }),
      });

      logger.info({ aiSystemId: action.aiSystemId, restrictionType }, "AI system restricted");
      return true;
    } catch (error) {
      logger.error({ err: error }, "Restrict action failed");
      return false;
    }
  }

  /**
   * DOCUMENT: Create automated documentation entries
   */
  private async executeDocument(action: RequiredAction): Promise<boolean> {
    try {
      // For MVP: Create an audit log entry for documentation
      await storage.createAuditLog({
        action: 'automated_documentation',
        resourceType: 'compliance_action',
        resourceId: action.id,
        resourceName: `Documentation: ${action.description.substring(0, 50)}`,
        metadata: {
          actionId: action.id,
          aiSystemId: action.aiSystemId,
          description: action.description,
          assignee: action.assignee,
          deadline: action.deadline,
          automated: true,
        },
      });

      logger.info({ actionId: action.id }, "Documentation entry created");
      return true;
    } catch (error) {
      logger.error({ err: error }, "Document action failed");
      return false;
    }
  }
}

// Singleton instance
export const actionExecutor = new ActionExecutor();
